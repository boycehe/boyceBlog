<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="[算法与数据结构]排序算法"/>








  <link rel="alternate" href="/default" title="Boyce's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://boycehe.com/2018/09/23/算法与数据结构-排序算法/"/>


<meta name="description" content="排序是一种非常常见的一个问题。生活中有很多常见需要排序，处理各种数据也是经常需要对数据进行排序。获得图灵奖的Pascal之父——Nicklaus Wirth曾经有这么一句话，程序=数据+算法。因此在计算机领域，我们需要处理大量的数据，排序就显得尤其重要。首先，我有个观点，排序算法有难易之分，但没有高低贵贱之分。不能因为这个排序算法很简单就认为他不如难的算法。评判一个排序算法不仅要看他时间复杂度也要">
<meta property="og:type" content="article">
<meta property="og:title" content="[算法与数据结构]排序算法">
<meta property="og:url" content="http://boycehe.com/2018/09/23/算法与数据结构-排序算法/index.html">
<meta property="og:site_name" content="Boyce&#39;s Blog">
<meta property="og:description" content="排序是一种非常常见的一个问题。生活中有很多常见需要排序，处理各种数据也是经常需要对数据进行排序。获得图灵奖的Pascal之父——Nicklaus Wirth曾经有这么一句话，程序=数据+算法。因此在计算机领域，我们需要处理大量的数据，排序就显得尤其重要。首先，我有个观点，排序算法有难易之分，但没有高低贵贱之分。不能因为这个排序算法很简单就认为他不如难的算法。评判一个排序算法不仅要看他时间复杂度也要">
<meta property="og:updated_time" content="2019-03-13T15:55:41.407Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[算法与数据结构]排序算法">
<meta name="twitter:description" content="排序是一种非常常见的一个问题。生活中有很多常见需要排序，处理各种数据也是经常需要对数据进行排序。获得图灵奖的Pascal之父——Nicklaus Wirth曾经有这么一句话，程序=数据+算法。因此在计算机领域，我们需要处理大量的数据，排序就显得尤其重要。首先，我有个观点，排序算法有难易之分，但没有高低贵贱之分。不能因为这个排序算法很简单就认为他不如难的算法。评判一个排序算法不仅要看他时间复杂度也要">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> [算法与数据结构]排序算法 - Boyce's Blog </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Boyce's Blog</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          [算法与数据结构]排序算法
        
      </h1>

      <time class="post-time">
          Sep 23 2018
      </time>
    </header>



    
            <div class="post-content">
            <p>排序是一种非常常见的一个问题。生活中有很多常见需要排序，处理各种数据也是经常需要对数据进行排序。获得图灵奖的Pascal之父——Nicklaus Wirth曾经有这么一句话，程序=数据+算法。因此在计算机领域，我们需要处理大量的数据，排序就显得尤其重要。首先，我有个观点，排序算法有难易之分，但没有高低贵贱之分。不能因为这个排序算法很简单就认为他不如难的算法。评判一个排序算法不仅要看他时间复杂度也要看空间复杂度。我们应该根据我们具体的场景，选择适合我们的排序算法。下边我们分别介绍排序一些常见的算法</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>在很多算法的书中，冒泡排序是第一个被介绍的排序算法。因为冒泡排序实现容易，理解起来也比较简单。他的原理如下：</p>
<pre><code>- 从数据的某一端开始，依次与领近的元素按照升序或者降序相比较，如果不对，则交换他们两的位置
- 重复上边步骤直到不再有元素需要交换
</code></pre><p>因为这种排序的操作像一个气泡不停的网上冒，所以形象的成为冒泡排序。冒泡排序的时间复杂度O(n²);<br>下边c语言的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void sort(int a[], int n)</div><div class="line">&#123;</div><div class="line">	int i, j, temp;</div><div class="line">	for (j = 0; j &lt; n - 1; j++)</div><div class="line">		for (i = 0; i &lt; n - 1 - j; i++)</div><div class="line">		&#123;</div><div class="line">			if(a[i] &gt; a[i + 1])</div><div class="line">			&#123;</div><div class="line">				temp = a[i];</div><div class="line">				a[i] = a[i + 1];</div><div class="line">				a[i + 1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的原理是，每一趟从待排序的数据中选择最小（最大）的元素，顺序放在已排好序的序列最后，直到全部数据排序完毕。从这个原理我们也可以看出选择排序是一种不稳定的排序算法。他的时间复杂度可以达到O(n²)级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;math.h&gt;</div><div class="line"> </div><div class="line">#define MAX_SIZE 101</div><div class="line">#define SWAP(x, y, t)  ((t) = (x), (x) = (y), (y) = (t))</div><div class="line"> </div><div class="line">void sort(int[], int);      /* selection sort */</div><div class="line">void sort(int list[], int n)</div><div class="line">&#123;</div><div class="line">    int i, j, min, temp;</div><div class="line">    for (i = 0; i &lt; n - 1; i++)&#123;</div><div class="line">        min = i;</div><div class="line">        for (j = i + 1; j &lt; n; j++)</div><div class="line">        if (list[j] &lt; list[min])</div><div class="line">            min = j;</div><div class="line">        SWAP(list[i], list[min], temp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的算法主要思想是从一个待排序的数据中选出一个元素插入到一个有序的子序列中，插入后的序列也是有序的。重复这个步骤，直到带排序的序列为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void sort(int *arr[],int len)&#123;</div><div class="line">    int i;</div><div class="line">    int j;</div><div class="line">    int temp; </div><div class="line">    for(i=1;i&lt;len;i++)&#123;  </div><div class="line">        for(j=0;j&lt;i;j++)&#123;  </div><div class="line">            if(arr[j]&gt;arr[i])&#123;</div><div class="line">                temp=arr[i];</div><div class="line">                arr[i]=arr[j];</div><div class="line">                arr[j]=temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="双向冒泡排序"><a href="#双向冒泡排序" class="headerlink" title="双向冒泡排序"></a>双向冒泡排序</h3><p>双向冒泡排序是一种优化版，他的基本思想是冒泡排序不再始终从一端开始。而是左端到右端，右端到左端。同时有一个left和right记录左端和右端已经排好序的元素位置。虽然双向冒泡排序的时间复杂度是O(n²)，但是他的效率要比单纯的冒泡排序要高点。他可以避免如果序列按照升序排列，而尾部存在较多的小数字，则会导致小数字移到序列的头部很慢。双向冒泡排序则解决了这个问题。下边写下双向冒泡排序的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">void sort(int number[])</div><div class="line">&#123;</div><div class="line">    int left = 0, right = MAX - 1, shift = 1;</div><div class="line">    int i;</div><div class="line">     </div><div class="line">    while (left &lt; right)</div><div class="line">    &#123;</div><div class="line">        for (i = left; i &lt; right; i++)</div><div class="line">        &#123;</div><div class="line">            if (number[i] &gt; number[i+1])</div><div class="line">            &#123;</div><div class="line">                SWAP(number[i], number[i+1])</div><div class="line">                shift = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right = shift;</div><div class="line">        for (i = right-1; i &gt;= left; i--)</div><div class="line">        &#123;</div><div class="line">            if (number[i] &gt; number[i+1])</div><div class="line">            &#123;</div><div class="line">                SWAP(number[i], number[i+1])</div><div class="line">                shift = i + 1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left = shift;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序又称缩小增量排序，他的基本原理是。假设待排序的序列中个数为n，先选择一个整数m&lt;n，以m为间隔，将序列分为m个序列。所有距离为m的元素放在同一个序列中。在每一个子序列中分别实行直接插入排序。然后缩小m，重复上述步骤直至m=1。由于希尔排序并不是一个稳定排序。他的时间复杂度并不好确定。但他时间复杂度一般鉴于O(nlogn)到O(n²)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void sort(int iarr[],int length)</div><div class="line">&#123;</div><div class="line">    int dt[3] = &#123;5,3,1&#125;,i =0 ,j,k,temp;</div><div class="line">    for(j = 0; j &lt; 3; ++j)</div><div class="line">    &#123;</div><div class="line">        for(i = dt[j]; i &lt; length; ++i)</div><div class="line">        &#123;</div><div class="line">            temp = iarr[i];</div><div class="line">            k = i - dt[j];</div><div class="line">            while(temp &lt; iarr[k] &amp;&amp; k &gt;= 0)</div><div class="line">            &#123;</div><div class="line">                iarr[k + dt[j]] = iarr[k];</div><div class="line">                k -= dt[j];</div><div class="line">            &#125;</div><div class="line">            iarr[k + dt[j]] =  temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="梳排序"><a href="#梳排序" class="headerlink" title="梳排序"></a>梳排序</h3><p>梳排序的思想有点希尔排序类似。他是在冒泡排序的基础进行优化的一种更搞笑的算法。他也是通过增量分为若干个子序列。然后对子序列进行冒泡排序。然后在缩小增量，重复一下步骤，知道增量为1.因此他也是一种不稳定排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void comb_sort(int* data, int n)</div><div class="line">&#123;</div><div class="line">const double shrink = 1.25;</div><div class="line">int i, delta = n, noswap = 0;</div><div class="line">while(!noswap)</div><div class="line">&#123;</div><div class="line">for(noswap = 1, i = 0; i + delta &lt; n; i++)</div><div class="line">	if(data[i] &gt; data[i + delta])</div><div class="line">	&#123;</div><div class="line">		data[i] ^= data[i + delta];</div><div class="line">		data[i + delta] ^= data[i];</div><div class="line">		data[i] ^= data[i + delta];</div><div class="line">		noswap = 0;</div><div class="line">	&#125;</div><div class="line">	if(delta &gt; 1)</div><div class="line">	&#123;</div><div class="line">		delta /= shrink;</div><div class="line">		noswap = 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是使用了计算机中分而治之思想的一种排序算法。他的基本原理是，将序列划成更小子序列，将他们分别排序然后在归并，归并后再划分更小的子序列，重复上述步骤直至得到一个有序的序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">const int MAXN=200005;</div><div class="line">int n, a[MAXN], temp[MAXN];</div><div class="line">long long ans;</div><div class="line"></div><div class="line">void sort(int l, int r)</div><div class="line">&#123;    </div><div class="line">    if(r == l) return ;//结束条件</div><div class="line">    </div><div class="line">    int m = (l + r) &gt;&gt; 1;   </div><div class="line">    </div><div class="line">    count(l, m);</div><div class="line">    </div><div class="line">    count(m + 1, r);//二分查找</div><div class="line">    </div><div class="line">    int i = l, j = m + 1, k = l;</div><div class="line">    </div><div class="line">    	while(j &lt;= r || i &lt;= m)&#123;</div><div class="line">    	</div><div class="line">        if(j &gt; r || (i &lt;= m &amp;&amp; a[i] &lt; a[j]))</div><div class="line">            temp[k++] = a[i++];</div><div class="line">        else</div><div class="line">            temp[k++] = a[j++], ans += m - i + 1;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    	for(i = l; i &lt;= r; i++) &#123;</div><div class="line">		   	 a[i] = temp[i]</div><div class="line">	    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是对冒泡排序的另一种改进，他通过一趟排序，将序列分割成独立的两个序列，其中一个序列的数字都要比另一个序列的数字还小。然后对子序列重复以上步骤。然后将两个序列合并得到一个有序序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void sort(int *a, int left, int right)</div><div class="line">&#123;</div><div class="line">    if(left &gt;= right) return ;</div><div class="line"></div><div class="line">    int i = left;</div><div class="line">    int j = right;</div><div class="line">    int key = a[left];</div><div class="line">     </div><div class="line">    while(i &lt; j)      </div><div class="line">    &#123;</div><div class="line">        while(i &lt; j &amp;&amp; key &lt;= a[j])</div><div class="line">        &#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[i] = a[j];</div><div class="line">         </div><div class="line">        while(i &lt; j &amp;&amp; key &gt;= a[i])</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        a[j] = a[i];</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    a[i] = key;</div><div class="line">    sort(a, left, i - 1);</div><div class="line">    sort(a, i + 1, right);</div><div class="line">                    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序顾名思义，是利用堆这种数据结构的一种排序算法。堆是一个特殊的完全二叉树。他分为最大堆和最小堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">最大堆：父节点都要比子节点大，且根节点是最大的值</div><div class="line">最小堆：父节点都要比子节点小，且根节点是最小的值</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void swap(int* a, int* b) &#123;</div><div class="line">    int temp = *b;</div><div class="line">    *b = *a;</div><div class="line">    *a = temp;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void max_heapify(int arr[], int start, int end) &#123;</div><div class="line">    int dad = start;</div><div class="line">    int son = dad * 2 + 1;</div><div class="line">    while (son &lt;= end) &#123; </div><div class="line">        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) </div><div class="line">            son++;</div><div class="line">        if (arr[dad] &gt; arr[son]) </div><div class="line">            return;</div><div class="line">        else &#123; </div><div class="line">            swap(&amp;arr[dad], &amp;arr[son]);</div><div class="line">            dad = son;</div><div class="line">            son = dad * 2 + 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void sort(int arr[], int len) &#123;</div><div class="line">    int i;</div><div class="line">    </div><div class="line">    for (i = len / 2 - 1; i &gt;= 0; i--)</div><div class="line">        max_heapify(arr, i, len - 1);</div><div class="line">    for (i = len - 1; i &gt; 0; i--) &#123;</div><div class="line">        swap(&amp;arr[0], &amp;arr[i]);</div><div class="line">        max_heapify(arr, 0, i - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

            </div>
          

    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">John Doe.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
