<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="iOS内存管理系列之一（原理及实现）"/>








  <link rel="alternate" href="/default" title="Boyce's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://boycehe.com/2018/12/02/iOS内存管理系列之一（原理及实现）/"/>


<meta name="description" content="iOS内存管理系列之一（原理及实现） 为什么要写这篇文章 最近在做内存优化相关的问题，趁着这个机会把内存相关知识捋一捋。虽然现在语言设计的趋势之一就是，让程序员不在关心内存管理这件事。但是作为一名程序开发，如果因为语言这个特性，而忽略这方面的知识的话，那是很不可取的，不懂这方面知识，遇到问题会让我们知其然还不知其所以然。因为内存设计的知识比较多，因此我把他做成了系列。第一部分讲下基础的知识和原理，">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS内存管理系列之一（原理及实现）">
<meta property="og:url" content="http://boycehe.com/2018/12/02/iOS内存管理系列之一（原理及实现）/index.html">
<meta property="og:site_name" content="Boyce&#39;s Blog">
<meta property="og:description" content="iOS内存管理系列之一（原理及实现） 为什么要写这篇文章 最近在做内存优化相关的问题，趁着这个机会把内存相关知识捋一捋。虽然现在语言设计的趋势之一就是，让程序员不在关心内存管理这件事。但是作为一名程序开发，如果因为语言这个特性，而忽略这方面的知识的话，那是很不可取的，不懂这方面知识，遇到问题会让我们知其然还不知其所以然。因为内存设计的知识比较多，因此我把他做成了系列。第一部分讲下基础的知识和原理，">
<meta property="og:updated_time" content="2018-12-02T07:21:53.684Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS内存管理系列之一（原理及实现）">
<meta name="twitter:description" content="iOS内存管理系列之一（原理及实现） 为什么要写这篇文章 最近在做内存优化相关的问题，趁着这个机会把内存相关知识捋一捋。虽然现在语言设计的趋势之一就是，让程序员不在关心内存管理这件事。但是作为一名程序开发，如果因为语言这个特性，而忽略这方面的知识的话，那是很不可取的，不懂这方面知识，遇到问题会让我们知其然还不知其所以然。因为内存设计的知识比较多，因此我把他做成了系列。第一部分讲下基础的知识和原理，">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> iOS内存管理系列之一（原理及实现） - Boyce's Blog </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Boyce's Blog</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          iOS内存管理系列之一（原理及实现）
        
      </h1>

      <time class="post-time">
          Dec 2 2018
      </time>
    </header>



    
            <div class="post-content">
            <h1>iOS内存管理系列之一（原理及实现）</h1>
<h3>为什么要写这篇文章</h3>
<p>最近在做内存优化相关的问题，趁着这个机会把内存相关知识捋一捋。虽然现在语言设计的趋势之一就是，让程序员不在关心内存管理这件事。但是作为一名程序开发，如果因为语言这个特性，而忽略这方面的知识的话，那是很不可取的，不懂这方面知识，遇到问题会让我们知其然还不知其所以然。因为内存设计的知识比较多，因此我把他做成了系列。第一部分讲下基础的知识和原理，第二部分讲下一些开源监测内存泄漏的实现。第三部分讲下如何利用开源工具做相关的APM。文章中难免有出错的地方，还请各位斧正。</p>
<h3>为什么要进行内存管理</h3>
<p>内存是计算机的稀缺资源，在移动设备乃至嵌入设备就显得更为稀缺。不同的操作系统对程序运行时所占用的内存要求不一样。在这里我们主要说一下移动操作系统对运行中App所占用的内存限制。Android不同Rom在默认情况下，对单个App所能申请的内存是有上限。这里的上限没有一个统一的具体值，但可以肯定的是，这个上限是存在的。iOS也同样如此。做移动开发的同学对此应该都会有所感受。内存管理是移动日常开发中非常重要的一环。因此，作为移动开发的我们，不仅要知其然，也要知其所以然。</p>
<h3>程序内存空间布局</h3>
<p>一个程序被加载到内存中，内存布局通常是分为如下几块。主要分为，代码段，数据段，栈，堆。不同语言的程序可能有所不同，比如C++还会具体区分为全局/静态存储区，常量区，自由存储区。这里主要关注，属于程序员可以分配和释放的部分。虽然有些语言使用了GC技术，但是我们在写代码时候依然要关注内存的分配和释放。</p>
<h3>常见的内存管理技术</h3>
<p>现代的内存管理技术主要集中在GC（Garbage Collection）上，现在很多语言也在使用GC技术，GC中的内存管理技术主要是有以下这些：</p>
<ul>
<li>标记清除算法</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标记清除算法是有两个部分组成，分别是标记阶段和清除阶段。标记阶段就是对对象进行遍历，将所有可达的对象进行标记。在清除阶段，会将那些没有被标记的对象进行回收，收回内存。这个算法的优缺点容易造成内存碎片</div></pre></td></tr></table></figure></p>
<ul>
<li>标记复制算法</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标记复制算法就是把活动对象复制到新的空间，然后把旧的控件全部释放掉。这个算法不会像清除算法一样产生大量的碎片，因为他是一次把就有空间释放掉，因此吞吐量比较大。速度较快。他缺点也很明显，算法使用可能会用到AB两个空间，对的使用率较低，同时在实现的时候不可能避免的产生递归调用</div></pre></td></tr></table></figure></p>
<ul>
<li>标记压缩算法</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">相比较上边的标记清除算法，标记压缩算法会把可达的对象重新排列起来，减少可达对象之间的间隙。这样就不产生内存碎片。相比复制算法不用开辟两个空间，也节约了空间。</div></pre></td></tr></table></figure></p>
<ul>
<li>引用计数法</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">引用计数法，内部保存一个计数器，保存了被多少个程序引用。当没有被其他程序引用时候，内存会被回收。相比于其他的算法，引用技术法。有以下的优点，可以及时的回收垃圾，查找次数少。但引用计数有一个比较致命的缺点，无法解决循环引用问题。</div></pre></td></tr></table></figure></p>
<p>通过上边对内存管理技术介绍，作为iOS开发会对引用计数法有种熟悉的感觉。iOS也是用到了这个技术，只是实现有所不同。</p>
<h3>iOS的内存管理技术</h3>
<h4>MRC</h4>
<p>通过上边关于常见内存管理技术的介绍，我们知道iOS使用的是引用计数这一技术。在前几年iOS是手动管理引用计数的也就是MRC(manual retain-release),MRC，需要程序员自己管理一个对象的引用计数。随着ARC（Automatic Reference Counting）技术的发展。现在已经很少看到ARC的代码。在MRC时代，程序员要手动管理引用计数，通常要遵循一下几个原则</p>
<ul>
<li>开头为<code>alloc</code>，<code>new</code>，<code>copy</code>，<code>mutableCopy</code>的方法创建的对象，引用计数都会被+1，</li>
<li>同时，如果需要对对象进行引用，可以通过retain来使引用计数+1，</li>
<li>不在使用该对象时候，通过release使应用计数-1。</li>
<li>不要release你没有拥有的对象</li>
</ul>
<h4>ARC</h4>
<p>在ARC时代，我们不需要手动retain，relase。由于ARC是一种编译器的技术，因此他本质上并没有变。以前MRC的知识依然是有用且是必要的。ARC引入了一些新的关键词，如strong，weak，__strong,__weak,__unsafe_reatian等等，值得关注是weak，__weak。这两个关键词会在对象释放后，会将引用置位nil，从而避免了野指针的问题。同时，我们也要注意ARC所能管理的只是OC对象，对于非OC的对象，ARC并不会管理他们的内存问题。所以在一个对象转成c的时候，我们要进行桥接。告诉这个编译器对象生命周期有程序员自己来控制；这时候程序员需要手动管理c指针的生命周期。同时C指针转化为OC对象时候，也要进行桥接，这时候桥接的含义则生命周期管理交由ARC管理。你要对它负责。因此我们可以看出来ARC相对于MRC来说，减轻了程序员的负担，不用写大量的retain，relase的代码，同时使用weak,__weak关键字可以有效的避免野指针的问题。其背后的原理则没有变。</p>
<h4>iOS内存的代码实现</h4>
<p>苹果的runtime源码可以在这里看<a href="https://opensource.apple.com/source/objc4/objc4-723/" target="_blank" rel="noopener">runtime</a>,如果你觉得这样看不方便的话，你可以通过wget把源码现在下来看，具体命令如下所示
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -c -r -np -k -L -p https://opensource.apple.com/source/objc4/objc4-723/</div></pre></td></tr></table></figure></p>
<p>下边我看看苹果的源码是如何实现。
<code>https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html</code></p>
<h5>alloc</h5>
<p>使用一个对象，首先我们得要对象分配内存，所以我们首先来看下alloc的实现吧：
alloc方法很简单，里边只是调用了一个c函数  _objc_rootAlloc(Class cls)；</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)alloc &#123;</div><div class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而<code>_objc_rootAlloc</code>则调用了<code>callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</code>函数；</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> _objc_rootAlloc(Class cls)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此我们只需要重点关注callAlloc这个函数的逻辑，剖析这个函数的行为和功能。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span> callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="meta">#if __OBJC2__</span></div><div class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</div><div class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;</div><div class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</div><div class="line">            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize());</div><div class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</div><div class="line">            obj-&gt;initInstanceIsa(cls, dtor);</div><div class="line">            <span class="keyword">return</span> obj;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</div><div class="line">            <span class="keyword">return</span> obj;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [cls alloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())</div></pre></td></tr></table></figure></p>
<p>fastpath 是一个编译优化的宏，他会告诉编译器刮号里边的值大概率是什么，从而编译器在代码优化过程中进行相应汇编指令的优化。这里主要是判断子类或者当前类有没有实现<code>alloc/allocWithZone</code>。如果有实现的话则直接进入</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</div><div class="line"><span class="keyword">return</span> [cls alloc];</div></pre></td></tr></table></figure></p>
<p>没有实现的话，那么会进入稍复杂的判断逻辑里边，通过宏定义可以看出我们是不支持fastalloc的，所以相关部分逻辑我们暂时忽略过。所以我们只需要关注class_createInstance这个函数的实现。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> class_createInstance(Class cls, size_t extraBytes)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> __attribute__((always_inline))  <span class="keyword">id</span> _class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, </div><div class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </div><div class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    assert(cls-&gt;isRealized());</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</div><div class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</div><div class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</div><div class="line"></div><div class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</div><div class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> obj;</div><div class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</div><div class="line">        obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</div><div class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (zone) &#123;</div><div class="line">            obj = (<span class="keyword">id</span>)malloc_zone_calloc ((malloc_zone_t *)zone, <span class="number">1</span>, size);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        obj-&gt;initIsa(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</div><div class="line">        obj = _objc_constructOrFree(obj, cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个<code>_class_createInstanceFromZone</code>方法中给对象分配了相应的内存。而初始化则调用了<code>initInstanceIsa</code> 和 <code>initIsa</code>两个方法。而 <code>initInstanceIsa</code> 只是在调用<code>initIsa</code>前进行了判断。因此我们只需要分析<code>initIsa</code>方法。从方法名字看，似乎是对<code>isa</code>进行初始化。是不是这样呢？我进入到方法内部看看具体实现</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::initIsa(Class cls)</div><div class="line">&#123;</div><div class="line">    initIsa(cls, <span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::initIsa(Class cls, <span class="keyword">bool</span> nonpointer, <span class="keyword">bool</span> hasCxxDtor) </div><div class="line">&#123; </div><div class="line">    assert(!isTaggedPointer()); </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</div><div class="line">        isa.cls = cls;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        assert(!DisableNonpointerIsa);</div><div class="line">        assert(!cls-&gt;instancesRequireRawIsa());</div><div class="line">        isa_t newisa(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="meta">#if SUPPORT_INDEXED_ISA</span></div><div class="line">        assert(cls-&gt;classArrayIndex() &gt; <span class="number">0</span>);</div><div class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</div><div class="line">        newisa.has_cxx_dtor = hasCxxDtor;</div><div class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</div><div class="line"><span class="meta">#else</span></div><div class="line">        newisa.bits = ISA_MAGIC_VALUE;</div><div class="line">        newisa.has_cxx_dtor = hasCxxDtor;</div><div class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">        isa = newisa;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里代码很简单只是简单的赋值操作这里不做细讲，可以说从名字上就可以看出来这个函数要干嘛了。</p>
<h5>retain</h5>
<p><code>retain</code>是对引用计数+1操作。分配完内存后我来看看<code>retain</code>是如何实现的</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span> &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetain();</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE <span class="keyword">id</span> objc_object::rootRetain()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> rootRetain(<span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE <span class="keyword">id</span> objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    isa_t oldisa;</div><div class="line">    isa_t newisa;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        transcribeToSideTable = <span class="literal">false</span>;</div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</div><div class="line">        &#125;</div><div class="line">     </div><div class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        uintptr_t carry;</div><div class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</div><div class="line">     </div><div class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</div><div class="line">                ClearExclusive(&amp;isa.bits);</div><div class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</div><div class="line">            sideTableLocked = <span class="literal">true</span>;</div><div class="line">            transcribeToSideTable = <span class="literal">true</span>;</div><div class="line">            newisa.extra_rc = RC_HALF;</div><div class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</div><div class="line">        sidetable_addExtraRC_nolock(RC_HALF);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来主要看<code>rootRetain</code>的逻辑，他接受两个bool参数。如果是<code>TaggedPointer</code>对象的话直接返回this。因此<code>TaggedPointer</code>的对象调用reatin不会改变引用计数。这个函数里边有个<code>do{}while()</code>的循环，当<code>isa.bits</code>中的值被更新后则循环结束。我们一步一步看下do里边的逻辑。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">    ClearExclusive(&amp;isa.bits);</div><div class="line">    <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">    <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这段逻辑主要处理当前类没有开启进行内存优化的情况。这里主要有两个函数<code>sidetable_tryRetain</code>和<code>sidetable_retain</code>。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">bool</span> objc_object::sidetable_tryRetain()</div><div class="line">&#123;</div><div class="line"><span class="meta">#if SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#endif</span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) &#123;</div><div class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_RC_ONE;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_DEALLOCATING) &#123;</div><div class="line">        result = <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        it-&gt;second += SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span> objc_object::sidetable_retain()</div><div class="line">&#123;</div><div class="line"><span class="meta">#if SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#endif</span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line">    </div><div class="line">    table.lock();</div><div class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</div><div class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>sidetable_tryRetain</code>函数主要做了这几件事,先从散列表中取出数值，如果这个数值找不到，就在Map添加SIDE_TABLE_RC_ONE值，如果这个数值所在的对象正在析构，那么将result置位false。最后检查下这个数字是否溢出，如果没有溢出则将引用计数+1；而<code>sidetable_retain</code>函数加了个自旋锁，同时逻辑更简单些。检查是否数值是否溢出，没有溢出则引用计数+1；
说完这两个函数，我们在回到<code>rootTryRetain()</code>函数。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</div><div class="line">    ClearExclusive(&amp;isa.bits);</div><div class="line">    <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的逻辑判断对象是否在析构。如果在析构则会进行相关处理操作。这下来我们看看开启了指针优化后的<code>retain</code>逻辑</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</div></pre></td></tr></table></figure></p>
<p>这行也是对引用计数+1的，是对其中的extra_rc进行+1</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span> (slowpath(carry)) &#123;</div><div class="line">     <span class="keyword">if</span> (!handleOverflow) &#123;</div><div class="line">         ClearExclusive(&amp;isa.bits);</div><div class="line">         <span class="keyword">return</span> rootRetain_overflow(tryRetain);</div><div class="line">      &#125;</div><div class="line">     <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</div><div class="line">     sideTableLocked = <span class="literal">true</span>;</div><div class="line">     transcribeToSideTable = <span class="literal">true</span>;</div><div class="line">     newisa.extra_rc = RC_HALF;</div><div class="line">     newisa.has_sidetable_rc = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里判断是否溢出，如果溢出了就会进入到rootRetain_overflow函数里边，而rootRetain_overflow函数则又调用了rootRetain，只不过handleOverflow会传true，同时会处理溢出的情况，这时候<code>transcribeToSideTable</code>为true，在结束后就会调用<code>sidetable_addExtraRC_nolock(RC_HALF);</code>,我们来看下这个函数的实现。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> </div><div class="line">objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)</div><div class="line">&#123;</div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line"></div><div class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</div><div class="line">    size_t oldRefcnt = refcntStorage;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">    uintptr_t carry;</div><div class="line">    size_t newRefcnt = </div><div class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</div><div class="line">    <span class="keyword">if</span> (carry) &#123;</div><div class="line">        refcntStorage =</div><div class="line">            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        refcntStorage = newRefcnt;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之前我们调用addc发现溢出后，我们把<code>newisa.extra_rc</code> 置位<code>RC_HALF</code>,同时我们调用<code>sidetable_addExtraRC_nolock</code>同时把剩下的<code>RC_HALF</code>加入散列表中;也是通过addc进行操作。如果这是溢出则恢复散列表中的值，至此retain的逻辑差不多结束了。</p>
<h5>release</h5>
<p>看完<code>retain</code>源码，喘口气继续看看<code>release</code>是怎么实现的吧</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</div><div class="line">    ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRelease();</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE <span class="keyword">bool</span> objc_object::rootRelease()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE <span class="keyword">bool</span> objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    isa_t oldisa;</div><div class="line">    isa_t newisa;</div><div class="line"></div><div class="line"> retry:</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</div><div class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        uintptr_t carry;</div><div class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</div><div class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</div><div class="line">            <span class="keyword">goto</span> underflow;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                             oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line"> underflow:</div><div class="line">    newisa = oldisa;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</div><div class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            sidetable_lock();</div><div class="line">            sideTableLocked = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">goto</span> retry;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</div><div class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  </div><div class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                                oldisa.bits, newisa.bits);</div><div class="line">            <span class="keyword">if</span> (!stored) &#123;</div><div class="line">            </div><div class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</div><div class="line">                isa_t newisa2 = oldisa2;</div><div class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</div><div class="line">                    uintptr_t overflow;</div><div class="line">                    newisa2.bits = </div><div class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</div><div class="line">                    <span class="keyword">if</span> (!overflow) &#123;</div><div class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </div><div class="line">                                                       newisa2.bits);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!stored) &#123;</div><div class="line">                sidetable_addExtraRC_nolock(borrowed);</div><div class="line">                <span class="keyword">goto</span> retry;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sidetable_unlock();</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</div><div class="line">        ClearExclusive(&amp;isa.bits);</div><div class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</div><div class="line">        <span class="keyword">return</span> overrelease_error();</div><div class="line">    &#125;</div><div class="line">    newisa.deallocating = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line"></div><div class="line">    __sync_synchronize();</div><div class="line">    <span class="keyword">if</span> (performDealloc) &#123;</div><div class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看完调用顺序后，我们着重分析下这个函数吧</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</div></pre></td></tr></table></figure></p>
<p>同样如果是<code>TaggedPointer</code>对象直接返回 false。我们先看<code>retry:</code>代码段
这里边的部分逻辑与<code>retain</code>相似，我们不一一分析。如果没有开启指针优化的话会有调用这样关键函数</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">uintptr_t</div><div class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</div><div class="line">&#123;</div><div class="line"><span class="meta">#if SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#endif</span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    table.lock();</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) &#123;</div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</div><div class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> do_dealloc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要做了这几个逻辑，如果在散列表中没有找到对象，那么将其中的值置为<code>SIDE_TABLE_DEALLOCATING</code>。如果找到值比<code>SIDE_TABLE_DEALLOCATING</code>还小那么将it中<code>second</code>置位<code>SIDE_TABLE_DEALLOCATING</code>。如果找到的值不属于上边情况。那么检查是否溢出，没有溢出则引用计数-1；最后如果这个<code>do_dealloc</code>为true（这个链路里边的performDealloc为true）那么就给会给发送一个SEL_dealloc 的消息进行释放。分析完这个函数后我们继续回到<code>rootRelease</code>中，下边代码是开启了指针优化的情况，接下来会调用</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uintptr_t carry;</div><div class="line">newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</div></pre></td></tr></table></figure></p>
<p>将引用计数-1；同时 会做溢出判断，如果已经溢出了，则会跳到<code>underflow:</code>代码段。这段代码的主要逻辑在一个长长的if语句里边。这里边先判断<code>has_sidetable_rc</code>这个属性，这个属性代表如果为yes，那么代表会有部分引用计数存到一table里边。如果没有那么说明已经没有引用了。直接走释放逻辑。如果有的话，那么要从table中取出引用计数，然后进行-1操作，然后赋值给<code>newisa.extra_rc</code>，如果-1操作失败会立即进行一次。如果还是失败那么要table中引用计数恢复，然后进入retry代码重复这样的逻辑.</p>
<h5>autolrease</h5>
<p>最后说一下autolrease吧，先贴上调用栈。
<code>@autoreleasepool{}</code>经过<code>clang -rewrite-objc</code>命令后，我们可以看到</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样的结构体。初始化的时候会调用objc_autoreleasePoolPush()方法，~相当于OC中的delloc方法，他会调用objc_autoreleasePoolPop(atautoreleasepoolobj)方法，传入的参数就是我们刚刚通过objc_autoreleasePoolPush()生成的对象。关于<code>@autoreleasepool{}</code>的创建和释放逻辑我们看这两个函数就可以了。我们先从<code>objc_autoreleasePoolPush()</code>这个函数开始。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() </div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> *dest;</div><div class="line">    <span class="keyword">if</span> (DebugPoolAllocation) &#123;</div><div class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</div><div class="line">    &#125;</div><div class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</div><div class="line">    <span class="keyword">return</span> dest;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">  AutoreleasePoolPage *page = hotPage();</div><div class="line">  <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">      <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</div><div class="line">      <span class="keyword">return</span> autoreleaseFullPage(obj, page);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> autoreleaseNoPage(obj);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里边会调用AutoreleasePoolPage类的push()方法，我们看一下AutoreleasePoolPage结构</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AutoreleasePoolPage </div><div class="line">&#123;</div><div class="line"> </div><div class="line"><span class="meta">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)</span></div><div class="line"><span class="meta">#   define POOL_BOUNDARY nil</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> pthread_key_t <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</div><div class="line">    <span class="keyword">static</span> uint8_t <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></div><div class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> SIZE = </div><div class="line"><span class="meta">#if PROTECT_AUTORELEASEPOOL</span></div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></div><div class="line"><span class="meta">#else</span></div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(<span class="keyword">id</span>);</div><div class="line"></div><div class="line">    magic_t <span class="keyword">const</span> magic;</div><div class="line">    <span class="keyword">id</span> *next;</div><div class="line">    pthread_t <span class="keyword">const</span> thread;</div><div class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</div><div class="line">    AutoreleasePoolPage *child;</div><div class="line">    uint32_t <span class="keyword">const</span> depth;</div><div class="line">    uint32_t hiwat;</div><div class="line">    </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><code>EMPTY_POOL_PLACEHOLDER</code>这个宏看名字意思是占位的意思。</p>
<p>从作用上来看，当一个外部调用第一次调用创建AutoreleasePoolPage，但是没有任何要进栈的对象时候，那么他不会先创建一个AutoreleasePoolPage对象，而是把EMPTY_POOL_PLACEHOLDER作为指针返回，并用TLS技术绑定当前线程。这样的实现有点像懒加载，在需要的时候才创建对象。</p>
<p><code>POOL_BOUNDARY</code>这个之前是<code>POOL_SENTINEL</code>，他们同样值都是nil。</p>
<p>作用都是在第一次有对象入栈时候会push一个空的对象。这样以后在pop的时候通过判断值是不是nil，知道是不是栈底了。相比于<code>POOL_SENTINEL</code>我更觉得<code>POOL_BOUNDARY</code>意思简洁明了。</p>
<p><code>static pthread_key_t const key = AUTORELEASE_POOL_KEY</code> 这个这个就是TLS把当前hotpage或者EMPTY_POOL_PLACEHOLDER存储在当前线程的key。没有什么好说的。</p>
<p><code>static uint8_t const SCRIBBLE = 0xA3;</code>这个是常数值，唯一的作用就是在releasing的时候通过<code>memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</code>把page的next置位0xA3A3A3A3</p>
<p><code>magic_t const magic;</code>这个<code>magic</code>用来校验类的完整性。
<code>id *next;</code>栈的指针。
<code>pthread_t const thread;</code>用于保存线程。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AutoreleasePoolPage * <span class="keyword">const</span> parent;</div><div class="line">AutoreleasePoolPage *child;</div><div class="line">uint32_t <span class="keyword">const</span> depth;</div><div class="line">uint32_t hiwat;</div></pre></td></tr></table></figure></p>
<p>这几个属性都是跟双向链表有关系，<code>parent</code>指向父节点，<code>child</code>指向子节点。<code>depth</code>这个是层级，<code>hiwat</code>这个应该栈里数据的数量。</p>
<p>分析完这个类的结构。我们继续看调用的流程。再调用到<code>static inline id *autoreleaseFast(id obj)</code>方法时，里边有三个分支走向。我们首先看下一个关键一行
<code>AutoreleasePoolPage *page = hotPage();</code>这个<code>hotPage()</code>是通过TLS取当前的AutoreleasePoolPage的。如果是EMPTY_POOL_PLACEHOLDER的话直接返回nil，否则的话就会返回AutoreleasePoolPage，返回之前会做一个完整性检测。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">      <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</div><div class="line">      <span class="keyword">return</span> autoreleaseFullPage(obj, page);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> autoreleaseNoPage(obj);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这个判断也是比较简单的，如果当前不为nil，且没有满则直接调用add函数，添加obj。这个add函数也是比较简单入栈操作。只是在入栈的时候做了线程保护。当然我们根据宏是没有启用这个线程保护功能的。如果当前page已经满了，那么会调用<code>autoreleaseFullPage</code>方法。我们看下<code>autoreleaseFullPage</code>怎么实现的。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> __attribute__((noinline))</div><div class="line">  <span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page)</div><div class="line">  &#123;</div><div class="line">      assert(page == hotPage());</div><div class="line">      assert(page-&gt;full()  ||  DebugPoolAllocation);</div><div class="line"></div><div class="line">      <span class="keyword">do</span> &#123;</div><div class="line">          <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</div><div class="line">          <span class="keyword">else</span> page = new AutoreleasePoolPage(page);</div><div class="line">      &#125; <span class="keyword">while</span> (page-&gt;full());</div><div class="line"></div><div class="line">      setHotPage(page);</div><div class="line">      <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法的逻辑也没有复杂的地方。你遍历子节点直到找到没有满的page，如果最后都没有找到，那么就新建一个page，然后把这个page绑定到当前线程。同时调用add方法添加这个obj。然后我们再看下最后一个分支走向<code>autoreleaseNoPage(obj)</code>方法</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> __attribute__((noinline))</div><div class="line">  <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)</div><div class="line">  &#123;</div><div class="line">      </div><div class="line">      assert(!hotPage());</div><div class="line"></div><div class="line">      <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;</div><div class="line">          </div><div class="line">          pushExtraBoundary = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</div><div class="line">          _objc_inform(<span class="string">"MISSING POOLS: (%p) Object %p of class %s "</span></div><div class="line">                       <span class="string">"autoreleased with no pool in place - "</span></div><div class="line">                       <span class="string">"just leaking - break on "</span></div><div class="line">                       <span class="string">"objc_autoreleaseNoPool() to debug"</span>, </div><div class="line">                       pthread_self(), (<span class="keyword">void</span>*)obj, object_getClassName(obj));</div><div class="line">          objc_autoreleaseNoPool(obj);</div><div class="line">          <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</div><div class="line">          </div><div class="line">          <span class="keyword">return</span> setEmptyPoolPlaceholder();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);</div><div class="line">     setHotPage(page);</div><div class="line">     </div><div class="line">     <span class="keyword">if</span> (pushExtraBoundary) &#123;</div><div class="line">         page-&gt;add(POOL_BOUNDARY);</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>相比于前几个方法这个方法逻辑就稍稍复杂了点。<code>bool pushExtraBoundary = false;</code>这个属性表示要不要像栈里边添加<code>POOL_BOUNDARY</code>，这个只有在栈为空的时候才会是<code>true</code>。第二个if判断主要是用debug相关，这里先不管。第三个判断，如果传的是一个<code>POOL_BOUNDARY</code>对象且没有调试alloc的时候，会将当前线程绑定一个EMPTY_POOL_PLACEHOLDER的占位对象，并返回。经过这些判断，我们走到了这里</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);</div><div class="line">       setHotPage(page);</div><div class="line">       </div><div class="line"><span class="keyword">if</span> (pushExtraBoundary) &#123;</div><div class="line">    page-&gt;add(POOL_BOUNDARY);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">return</span> page-&gt;add(obj);</div></pre></td></tr></table></figure></p>
<p>这里的代码比较简单，新建一个<code>AutoreleasePoolPage</code>对象，并且设置为hotpage，然后如果<code>pushExtraBoundary</code>为true，则把<code>POOL_BOUNDARY</code>入栈，然后把obj入栈。最后返回page对象。这里大家可能有疑问了，这里有条件的将<code>POOL_BOUNDARY</code>入栈，为不为导致底不是<code>POOL_BOUNDARY</code>,有这个疑问是很好的。可以我们看整个NSObject.mm的代码，可以看到不会出现栈底元素不是<code>POOL_BOUNDARY</code>的。至此，我们把<code>@autorelease{}</code>代码的新建逻辑分析完毕。下边我们来看释放逻辑。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) </div><div class="line">    &#123;</div><div class="line">        AutoreleasePoolPage *page;</div><div class="line">        <span class="keyword">id</span> *stop;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</div><div class="line">            <span class="keyword">if</span> (hotPage()) &#123;</div><div class="line">                pop(coldPage()-&gt;begin());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                setHotPage(<span class="literal">nil</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        page = pageForPointer(token);</div><div class="line">        stop = (<span class="keyword">id</span> *)token;</div><div class="line">        <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</div><div class="line">            <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</div><div class="line">            </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> badPop(token);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</div><div class="line"></div><div class="line">        page-&gt;releaseUntil(stop);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</div><div class="line">            AutoreleasePoolPage *parent = page-&gt;parent;</div><div class="line">            page-&gt;kill();</div><div class="line">            setHotPage(parent);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</div><div class="line">            page-&gt;kill();</div><div class="line">            setHotPage(<span class="literal">nil</span>);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</div><div class="line">            <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</div><div class="line">                page-&gt;child-&gt;kill();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</div><div class="line">                page-&gt;child-&gt;child-&gt;kill();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看调用流程，我们着重分析下<code>pop(void *token)</code>方法，我们先看下段代码块的逻辑：</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hotPage()) &#123;</div><div class="line">       pop(coldPage()-&gt;begin());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       setHotPage(<span class="literal">nil</span>);</div><div class="line">    &#125;</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段逻辑主要判断如果pop的是一个<code>EMPTY_POOL_PLACEHOLDER</code>,这个就是我们之前空池占位。那么先判断是否存在hotpage，若果存在的话，那么将调用pop方法，同时传入当前hotpage的最初的父节点，<code>coldPage()</code>返回的是第一个节点。如果不存在hotpage，那么将TLS绑定的值置位nil。我们继续看下边的代码块：</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">page = pageForPointer(token);</div><div class="line">stop = (<span class="keyword">id</span> *)token;</div><div class="line"><span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</div><div class="line">    <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</div><div class="line"></div><div class="line">     &#125; <span class="keyword">else</span> &#123;             </div><div class="line">         <span class="keyword">return</span> badPop(token);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>page = pageForPointer(token);</code>这个函数根据传入的token获取page的首指针。获取到page后，下边检查一下token，通常下我们pop最终会传入一个page的beigin指针。这个通常应该是POOL_BOUNDARY，这里主要是做异常处理。接下来我们会走到这个函数</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">page-&gt;releaseUntil(stop);</div></pre></td></tr></table></figure></p>
<p>这个函数的实现如下：</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">void</span> releaseUntil(<span class="keyword">id</span> *stop) </div><div class="line"> &#123;</div><div class="line">     </div><div class="line">   <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</div><div class="line">           </div><div class="line">     AutoreleasePoolPage *page = hotPage();</div><div class="line">     </div><div class="line">     <span class="keyword">while</span> (page-&gt;empty()) &#123;</div><div class="line">     page = page-&gt;parent;</div><div class="line">     setHotPage(page);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     page-&gt;unprotect();</div><div class="line">     <span class="keyword">id</span> obj = *--page-&gt;next;</div><div class="line">     memset((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</div><div class="line">     page-&gt;protect();</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</div><div class="line">        objc_release(obj);</div><div class="line">     &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     setHotPage(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的实现逻辑还是比较清楚的，他依次释放栈的内容直到遇到stop，并且把next指向的区域置为<code>SCRIBBLE</code>,然后把最近的栈为非空的置为当前的hotpage。最后我们看一下kill的相关逻辑</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</div><div class="line">    page-&gt;child-&gt;kill();</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</div><div class="line">    page-&gt;child-&gt;child-&gt;kill();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上边的判断逻辑主要是经过<code>releaseUntil</code>后，当前的page的栈已经被清空了，当前栈如果有子节点那么就释放子节点。最后我们看一下<code>kill</code>方法。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> kill() </div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</div><div class="line"></div><div class="line">    AutoreleasePoolPage *deathptr;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        deathptr = page;</div><div class="line">         page = page-&gt;parent;</div><div class="line">         <span class="keyword">if</span> (page) &#123;</div><div class="line">          page-&gt;unprotect();</div><div class="line">          page-&gt;child = <span class="literal">nil</span>;</div><div class="line">         page-&gt;protect();</div><div class="line">        &#125;</div><div class="line">            delete deathptr;</div><div class="line">   &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段逻辑就相当简单了，依次释放子节点。至此<code>@autorelease{}</code>就分析完毕了，关于<code>autorelease</code>方法这里就不再分析了，<code>autorelease</code>逻辑基本上与我们上边分析的高度重合，这里不展开。</p>
<h4>常见的容易造成泄漏的点</h4>
<p>分析完源码后，我们知道iOS中的引用计数是怎么实现的，但这只是初步。内存管理难点不是在原理，而是在复杂的场景下怎么保证内存不泄漏，这才是最难的。我们先列举常见的容易造成泄漏的点：</p>
<h5>循环引用</h5>
<p>引用计数计数最大的缺点就是他无法解决循环引用的问题。如果出现循环引用了，需要我们手动打破循环引用。否则会一直占用内存。常见的循环引用情况主要是block。因为block会强引用外部变量，如果外部变量也在强引用这个block。那么他们就会造成循环引用。比如</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> HasBlock *hasBlock = [[HasBlock alloc] init];</div><div class="line"></div><div class="line">[hasBlock setBlock:^&#123;</div><div class="line">        hasBlock.name = <span class="string">@"abc"</span>;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure></p>
<p>修改方法也很简单通过一个弱引用间接使用改造如下</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> HasBlock *hasBlock = [[HasBlock alloc] init];</div><div class="line"> __<span class="keyword">weak</span> HasBlock* weakHasBlock = hasBlock;</div><div class="line">[hasBlock setBlock:^&#123;</div><div class="line">        weakHasBlock.name = <span class="string">@"abc"</span>;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure></p>
<p>这样就可以解决循环引用，这个是比较常见循环引用情况网上有很多宏解决这个问题。这里不展开。</p>
<h5>使用单例的的一些情况</h5>
<p>在使用单例的时候要注意，特别是单例含有block回调方法时候。有些单例会强持有这些block。这种情况虽然不是循环引用，但也是造成了喜欢引用。所以在使用单例的时候要清楚。如系统有些方法这样使用会造成无法释放：</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"boyce"</span> object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line">        <span class="keyword">self</span>.name = <span class="string">@"boyce"</span>;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc&#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就造成了内存泄漏，这是因为NSNotificationCenter强引用了usingBlock，而usingBlock强引用了self，而NSNotificationCenter是个单例不会被释放，而self在被释放的时候才会去把自己从NSNotificationCenter中移除。类似的情况还有很多，比如一个数组中对象等等。这些内存泄漏不容易发现。</p>
<h5>NSTimer</h5>
<p>NSTimer会强引用传入的target，这时候如果加入NSRunLoop这个timer又会被NSRunLoop强引用</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">10</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(commentAnimation) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure></p>
<p>解决这个方法主动stoptimer，至少是不能在dealloc中stoptimer的。另外可以设置一个中间类，把target变成中间类。</p>
<h5>NSURLSession</h5>
<p>这个问题和上边的NSTimer类似</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSession</span> *section = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]</div><div class="line">                                                              delegate:<span class="keyword">self</span></div><div class="line">                                                         delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [section dataTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:path]</div><div class="line">                                            completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                                               <span class="comment">//Do something</span></div><div class="line">                                            &#125;];</div><div class="line">[task resume];</div></pre></td></tr></table></figure></p>
<p>这里NSURLSession会强引用了self。同时本地SSL会对一个NSURLSession缓存一段时间。所以即使没有强引用。也会造成内存泄漏。这里比较好的使用单例[NSURLSession sharedSession]</p>
<h5>非OC对象的内存问题</h5>
<p>在OC对象转换为非OC对象时候，要进行桥接。要把对象的控制权由ARC转换为程序员自己控制，这时候程序员要自己控制对象创建和释放。如下边的简单代码</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *name = <span class="string">@"boyce"</span>;</div><div class="line"><span class="built_in">CFStringRef</span> cfStringRef = (__bridge <span class="built_in">CFStringRef</span>) name;</div><div class="line"><span class="built_in">CFRelease</span>(cfStringRef);</div></pre></td></tr></table></figure></p>
<h5>其他泄漏情况</h5>
<p>如果present一个UINavigationController，如果返回的姿势不正确。会造成内存泄漏</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIViewController</span> *vc = [[<span class="built_in">UIViewController</span> alloc]init];</div><div class="line">  <span class="built_in">UINavigationController</span> *nav = [[<span class="built_in">UINavigationController</span> alloc]initWithRootViewController:vc];</div><div class="line">  [<span class="keyword">self</span> presentViewController:nav animated:<span class="literal">YES</span> completion:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure></p>
<p>如果在UIViewController里边调用的是</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure></p>
<p>那么就会造成内存泄漏，这里边测试发现vc是没有被释放的。需要这样调用</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.navigationController.topViewController == <span class="keyword">self</span>) &#123;</div><div class="line">       [<span class="keyword">self</span>.navigationController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h5>想说的</h5>
<p>我认为内存管理的一些基本原理还是比较简单容易理解，难就难在结合复杂的场景，在一些复杂的场景下我们比较不容易发现内存泄漏的点。但是当我们把内存泄漏解决后你会发现，原来就是这么回事!!!</p>
<h4>结束语</h4>
<p>这部分就到此结束了，我们介绍了内存管理的原理，实现以及造成泄漏的常见场景。下篇介绍一些开源检测内存泄漏工具以及他们的实现。谢谢大家</p>

            </div>
          

    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">John Doe.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
